---
title: "Take-home_Ex01"
author: "Yuheng Liang"
format: html
editor: visual
date: "September 02, 2024"
date-modified: "September 08,2024"
execute: 
  eval: true
  echo: true
  freeze: true
---

# Take home ex01:**Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar**

## 1.0 Overview

### 1.1 Objectives

Exercise Requirements:

-   Using appropriate function of **sf** and **tidyverse** packages, import and transform the downloaded armed conflict data and administrative boundary data into sf tibble data.frames.
-   Using the geospatial data sets prepared, derive quarterly KDE layers.
-   Using the geospatial data sets prepared, perform 2nd-Order Spatial Point Patterns Analysis.
-   Using the geospatial data sets prepared, derive quarterly spatio-temporal KDE layers.
-   Using the geospatial data sets prepared, perform 2nd-Order Spatio-temporal Point Patterns Analysis.
-   Using appropriate tmap functions, display the KDE and Spatio-temporal KDE layers on openstreetmap of Myanmar.
-   Describe the spatial patterns revealed by the KDE and Spatio-temporal KDE maps.

## 2.0 Setup

### 2.1 Dependencies

#### 2.1.1 Core Packages:

-   SF: This package provides functions for reading, manipulating, and visualizing simple features geometries. It's essential for working with spatial data in R.
-   tidyverse: A collection of packages including dplyr, ggplot2, and readr, provides a grammar of data manipulation. It's useful for data cleaning and transformation.
-   dplyr:
-   lubridate:
-   spatstat:

**Visualization Package:**

-   tmap: Create thematic maps quickly and easily. It's ideal for visualizing spatial data.

```{R}
pacman::p_load(tidyverse, sf, tmap, maptools, spatstat, spNetwork, classInt, viridis, arrow,dplyr,lubridate,spatstat,raster,Mass)
```

### 2.2 Datasets

-   **Armed conflict data**

-   **GIS Data**

## 3.0 Data warning

### 3.1 Importing Armed conflict data

-   Reads a CSV file named "ACLED_Myanmar.csv" and stores the data in a variable called acled_sf.
-   Converts to spatial object
-   Projects to a different coordinate system
-   Converts date format

```{R}
acled_sf <- read_csv("data/ACLED_Myanmar.csv")%>%
  st_as_sf(coords =c("longitude", "latitude"),crs=4326)%>%
  st_transform(crs=32647)%>%
  mutate(event_date =dmy(event_date))
```

check data

```{R}
head(acled_sf)
```

filtered data

```{R}
filtered_acled_data <- acled_sf %>%
  filter(event_date >= "2021-01-01" & event_date <= "2024-06-30")%>%
  mutate(quarter = quarter(event_date))
```

```{R}
glimpse(filtered_acled_data)
```
set new dataset by season
```{R}
seasonal_data <- filtered_acled_data %>%
  group_by(quarter) %>%
  group_split()

q1_data <- seasonal_data[[1]]
q2_data <- seasonal_data[[2]]
q3_data <- seasonal_data[[3]]
q4_data <- seasonal_data[[4]]
```

### 3.2 Importing GIS Data

Importing polygon feature data in shapefile format

```{R}
boundry <- st_read(dsn = "data/mmr_polbnda_adm1_250k_mimu_1", layer = "mmr_polbnda_adm1_250k_mimu_1")
```

Data inspection and visualisation

View Data Structures

```{R}
glimpse(boundary)
```

Vies crs

```{R}
st_crs(boundary)
```

transform data

```{R}
boundary_transformed <- st_transform(boundry,crs = 32647)
```

check the data after transform

```{R}
st_crs(boundary_transformed)
```

```{r}
glimpse(boundary_transformed)
```

visualisation the boundary_transformed

```{R}
ggplot(boundary_transformed)+geom_sf()
```

### 3.3 Geospatial Data wrangling
#### 3.3.1 Converting sf data frames to sp’s Spatial* class
```{R}
q1 <- as_Spatial(q1_data)
```
display
```{R}
head(q1)
```
```{R}
q2 <- as_Spatial(q2_data)
q3 <- as_Spatial(q3_data)
q4 <- as_Spatial(q4_data)
```

#### 3.3.2 Converting the Spatial* class into generic sp format

```{R}
q1_sp <- as(q1,"SpatialPoints")
q2_sp <- as(q2,"SpatialPoints")
q3_sp <- as(q3,"SpatialPoints")
q4_sp <- as(q4,"SpatialPoints")
```


display shows below:
```{R}
q1_sp
```

#### 3.3.3 Converting the generic sp format into spatstat’s ppp format

```{R}
q1_ppp <- as.ppp(st_coordinates(q1_data), st_bbox(q1_data))
q2_ppp <- as.ppp(st_coordinates(q2_data), st_bbox(q2_data))
q3_ppp <- as.ppp(st_coordinates(q3_data), st_bbox(q3_data))
q4_ppp <- as.ppp(st_coordinates(q4_data), st_bbox(q4_data))
```

#### 3.3.4 Handling duplicated point

```{R}
any(duplicated(q1_ppp))
any(duplicated(q2_ppp))
any(duplicated(q3_ppp))
any(duplicated(q4_ppp))
```
jittering approach
```{R}
q1_ppp_jit <- rjitter(q1_ppp,retry=TRUE,nsim=1,drop=TRUE)
q2_ppp_jit <- rjitter(q2_ppp,retry=TRUE,nsim=1,drop=TRUE)
q3_ppp_jit <- rjitter(q3_ppp,retry=TRUE,nsim=1,drop=TRUE)
q4_ppp_jit <- rjitter(q4_ppp,retry=TRUE,nsim=1,drop=TRUE)
```

check if any duplicayed points in this geospatial data.
```{R}
any(duplicated(q1_ppp_jit))
any(duplicated(q2_ppp_jit))
any(duplicated(q3_ppp_jit))
any(duplicated(q4_ppp_jit))
```

#### 3.3.5 Creating owin object
covert sgSpatialPolygon object into owin object of spatstat
```{R}
boundary_owin <- as.owin(boundary_transformed)
```
display
```{R}
plot(boundary_owin)
```

#### 3.3.6 combining point events object and owin object
```{r}
acledmy_ppp_q1 = q1_ppp[boundary_owin]
acledmy_ppp_q2 = q2_ppp[boundary_owin]
acledmy_ppp_q3 = q3_ppp[boundary_owin]
acledmy_ppp_q4 = q4_ppp[boundary_owin]
```

## 4.0 derive quarterly KDE layers
### 4.1 q1
```{R}
install.packages("MASS")
library(MASS)
for (q in 1) {
  
  # 提取坐标点
  coordinates <- st_coordinates(q1_data)
  lon <- coordinates[, 1]  # 经度
  lat <- coordinates[, 2]  # 纬度
  
  # 生成 KDE
  kde <- kde2d(lon, lat, n = 200)
  
  # 转换为 raster 并可视化
  kde_raster <- raster(kde)
  plot(kde_raster, main = paste("KDE for Quarter 1"))
}
```
### 4.2 q2

```{R}
for (q in 1) {
  
  # 提取坐标点
  coordinates <- st_coordinates(q2_data)
  lon <- coordinates[, 1]  # 经度
  lat <- coordinates[, 2]  # 纬度
  
  # 生成 KDE
  kde <- kde2d(lon, lat, n = 200)
  
  # 转换为 raster 并可视化
  kde_raster <- raster(kde)
  plot(kde_raster, main = paste("KDE for Quarter 2"))
}
```

### 4.3 q3

```{r}
for (q in 1) {
  
  # 提取坐标点
  coordinates <- st_coordinates(q3_data)
  lon <- coordinates[, 1]  # 经度
  lat <- coordinates[, 2]  # 纬度
  
  # 生成 KDE
  kde <- kde2d(lon, lat, n = 500)
  
  # 转换为 raster 并可视化
  kde_raster <- raster(kde)
  plot(kde_raster, main = paste("KDE for Quarter 3"))
}
```

### 4.4 q4
```{R}
for (q in 1) {
  
  # 提取坐标点
  coordinates <- st_coordinates(q4_data)
  lon <- coordinates[, 1]  # 经度
  lat <- coordinates[, 2]  # 纬度
  
  # 生成 KDE
  kde <- kde2d(lon, lat, n = 1000)
  
  # 转换为 raster 并可视化
  kde_raster <- raster(kde)
  plot(kde_raster, main = paste("KDE for Quarter 4"))
}
```
## 5.0 perform 2nd-Order Spatial Point Patterns Analysis
For a comprehensive analysis of the clustering or dispersion of armed conflict events in Myanmar on a region-wide scale for the period 2021-2024, I recommend the use of K-functions or L-functions. They provide information on clustering or dispersion at different distance scales on a global scale.

### 5.1 data examination
Checking whether a point pattern data is valid
```{R}
summary(q1_ppp)
```
### 5.2  Computing K-fucntion estimate
```{R}
K_q1 <- Kest(q1_ppp,correction = "Ripley")
K_q2 <- Kest(q2_ppp,correction = "Ripley")
K_q3 <- Kest(q3_ppp,correction = "Ripley")
K_q4 <- Kest(q4_ppp,correction = "Ripley")

```
display
```{R}
plot(K_q1, . -r ~ r, ylab= "K(d)-r")
plot(K_q2, . -r ~ r, ylab= "K(d)-r")
plot(K_q3, . -r ~ r, ylab= "K(d)-r")
plot(K_q4, . -r ~ r, ylab= "K(d)-r")

```
### 5.3 Computing L-fucntion estimate
```{R}
L1_ck <- Lest(q1_ppp, correction = "Ripley")
L2_ck <- Lest(q2_ppp, correction = "Ripley")
L3_ck <- Lest(q3_ppp, correction = "Ripley")
L4_ck <- Lest(q4_ppp, correction = "Ripley")
```
display
```{R}
plot(L1_ck, . -r ~ r)
plot(L2_ck, . -r ~ r)
plot(L3_ck, . -r ~ r)
plot(L4_ck, . -r ~ r)
```
### 5.4  Computing F-fucntion estimate
```{R}
F1_ck = Fest(q1_ppp)
F2_ck = Fest(q2_ppp)
F3_ck = Fest(q3_ppp)
F4_ck = Fest(q4_ppp)
```
diasplay
```{R}
plot(F1_ck)
plot(F2_ck)
plot(F3_ck)
plot(F4_ck)
```
### 5.5 Computing G-fucntion estimate
```{R}
G1_ck = Gest(q1_ppp, correction = "border")
G2_ck = Gest(q2_ppp, correction = "border")
G3_ck = Gest(q3_ppp, correction = "border")
G4_ck = Gest(q4_ppp, correction = "border")
```
display
```{R}
plot(G1_ck)
plot(G2_ck)
plot(G3_ck)
plot(G4_ck)
```

