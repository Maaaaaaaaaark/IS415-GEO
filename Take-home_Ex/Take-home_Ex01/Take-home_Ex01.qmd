---
title: "Take-home_Ex01"
author: "Yuheng Liang"
format: html
editor: visual
date: "September 02, 2024"
date-modified: "September 02,2024"
execute: 
  eval: true
  echo: true
  freeze: true
---

# Take home ex01:**Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar**

## 1.0 Overview

### 1.1 Objectives

Exercise Requirements:

-   Using appropriate function of **sf** and **tidyverse** packages, import and transform the downloaded armed conflict data and administrative boundary data into sf tibble data.frames.
-   Using the geospatial data sets prepared, derive quarterly KDE layers.
-   Using the geospatial data sets prepared, perform 2nd-Order Spatial Point Patterns Analysis.
-   Using the geospatial data sets prepared, derive quarterly spatio-temporal KDE layers.
-   Using the geospatial data sets prepared, perform 2nd-Order Spatio-temporal Point Patterns Analysis.
-   Using appropriate tmap functions, display the KDE and Spatio-temporal KDE layers on openstreetmap of Myanmar.
-   Describe the spatial patterns revealed by the KDE and Spatio-temporal KDE maps.

## 2.0 Setup

### 2.1 Dependencies

I will use these tools in this time Take home ex01

### Core Packages:

-   SF: This package provides functions for reading, manipulating, and visualizing simple features geometries. It's essential for working with spatial data in R.
-   tidyverse: A collection of packages including dplyr, ggplot2, and readr, provides a grammar of data manipulation. It's useful for data cleaning and transformation.
-   dplyr:
-   lubridate:
-   spatstat:

**Visualization Package:**

-   tmap: Create thematic maps quickly and easily. It's ideal for visualizing spatial data.

```{R}
pacman::p_load(tidyverse, sf, tmap, maptools, spatstat, spNetwork, classInt, viridis, arrow,dplyr,lubridate,spatstat,raster,Mass)
```

### 2.2 Datasets

-   **Armed conflict data**

-   **GIS Data**

## 3.0 Data warning

### 3.1 Importing Armed conflict data

-   Reads a CSV file named "ACLED_Myanmar.csv" and stores the data in a variable called acled_sf.
-   Converts to spatial object
-   Projects to a different coordinate system
-   Converts date format

```{R}
acled_sf <- read_csv("data/ACLED_Myanmar.csv")%>%
  st_as_sf(coords =c("longitude", "latitude"),crs=4326)%>%
  st_transform(crs=32647)%>%
  mutate(event_date =dmy(event_date))
```

check data

```{R}
head(acled_sf)
```

filtered data

```{R}
filtered_acled_data <- acled_sf %>%
  filter(event_date >= "2021-01-01" & event_date <= "2024-06-30")%>%
  mutate(quarter = quarter(event_date))
```

```{R}
glimpse(filtered_acled_data)
```
set new dataset by season
```{R}
seasonal_data <- filtered_acled_data %>%
  group_by(quarter) %>%
  group_split()

q1_data <- seasonal_data[[1]]
q2_data <- seasonal_data[[2]]
q3_data <- seasonal_data[[3]]
q4_data <- seasonal_data[[4]]
```

### 3.2 Importing GIS Data

Importing polygon feature data in shapefile format

```{R}
boundry <- st_read(dsn = "data/mmr_polbnda_adm1_250k_mimu_1", layer = "mmr_polbnda_adm1_250k_mimu_1")
```

Data inspection and visualisation

View Data Structures

```{R}
glimpse(boundary)
```

Vies crs

```{R}
st_crs(boundary)
```

transform data

```{R}
boundary_transformed <- st_transform(boundry,crs = 32647)
```

check the data after transform

```{R}
st_crs(boundary_transformed)
```

```{r}
glimpse(boundary_transformed)
```

visualisation the boundary_transformed

```{R}
ggplot(boundary_transformed)+geom_sf()
```

### 3.3 Geospatial Data wrangling
#### 3.3.1 Converting sf data frames to sp’s Spatial* class
```{R}
q1 <- as_Spatial(q1_data)
```
display
```{R}
head(q1)
```
```{R}
q2 <- as_Spatial(q2_data)
q3 <- as_Spatial(q3_data)
q4 <- as_Spatial(q4_data)
```

#### 3.3.2 Converting the Spatial* class into generic sp format

```{R}
q1_sp <- as(q1,"SpatialPoints")
q2_sp <- as(q2,"SpatialPoints")
q3_sp <- as(q3,"SpatialPoints")
q4_sp <- as(q4,"SpatialPoints")
```


display shows below:
```{R}
q1_sp
```

#### 3.3.3 Converting the generic sp format into spatstat’s ppp format

```{R}
q1_ppp <- as.ppp(st_coordinates(q1_data), st_bbox(q1_data))
q2_ppp <- as.ppp(st_coordinates(q2_data), st_bbox(q2_data))
q3_ppp <- as.ppp(st_coordinates(q3_data), st_bbox(q3_data))
q4_ppp <- as.ppp(st_coordinates(q4_data), st_bbox(q4_data))
```

#### 3.3.4 Handling duplicated point

```{R}
any(duplicated(q1_ppp))
any(duplicated(q2_ppp))
any(duplicated(q3_ppp))
any(duplicated(q4_ppp))
```
jittering approach
```{R}
q1_ppp_jit <- rjitter(q1_ppp,retry=TRUE,nsim=1,drop=TRUE)
q2_ppp_jit <- rjitter(q2_ppp,retry=TRUE,nsim=1,drop=TRUE)
q3_ppp_jit <- rjitter(q3_ppp,retry=TRUE,nsim=1,drop=TRUE)
q4_ppp_jit <- rjitter(q4_ppp,retry=TRUE,nsim=1,drop=TRUE)
```

check if any duplicayed points in this geospatial data.
```{R}
any(duplicated(q1_ppp_jit))
any(duplicated(q2_ppp_jit))
any(duplicated(q3_ppp_jit))
any(duplicated(q4_ppp_jit))
```

#### 3.3.5 Creating owin object
covert sgSpatialPolygon object into owin object of spatstat
```{R}
boundary_owin <- as.owin(boundary_transformed)
```
display
```{R}
plot(boundary_owin)
```

#### 3.3.6 combining point events object and owin object
```{r}
acledmy_ppp_q1 = q1_ppp[boundary_owin]
acledmy_ppp_q2 = q2_ppp[boundary_owin]
acledmy_ppp_q3 = q3_ppp[boundary_owin]
acledmy_ppp_q4 = q4_ppp[boundary_owin]
```

## 4.0 derive quarterly KDE layers
### 4.1 q1
```{R}
acledmy_ppp_q1_bw <- density(acledmy_ppp_q1,sigma=bw.diggle,edge=TRUE,kernel="gaussian")
```
display
```{R}
plot(acledmy_ppp_q1_bw)
```


```{R}
install.packages("MASS")
library(MASS)
for (q in 1) {
  
  # 提取坐标点
  coordinates <- st_coordinates(q1_data)
  lon <- coordinates[, 1]  # 经度
  lat <- coordinates[, 2]  # 纬度
  
  # 生成 KDE
  ppp_data <- ppp(lon, lat, window = boundary_owin)
  
  kde <- density(ppp_data)
  
  # 转换为 raster 并可视化
  kde_raster <- raster(kde)
  plot(kde_raster, main = paste("q1_data", q))
}
```
### 4.2 q2
```{R}
acledmy_ppp_q2_bw <- density(acledmy_ppp_q2,sigma=bw.diggle,edge=TRUE,kernel="gaussian")
```
display
```{R}
plot(acledmy_ppp_q2_bw)
```

```{R}
library(MASS)
for (q in 1) {
  
  # 提取坐标点
  coordinates <- st_coordinates(q2_data)
  lon <- coordinates[, 1]  # 经度
  lat <- coordinates[, 2]  # 纬度
  
  # 生成 KDE
  ppp_data <- ppp(lon, lat, window = boundary_owin)
  
  kde <- density(ppp_data)
  
  # 转换为 raster 并可视化
  kde_raster <- raster(kde)
  plot(kde_raster, main = paste("q2_data", q))
}
```

### 4.3 q3
```{R}
acledmy_ppp_q3_bw <- density(acledmy_ppp_q3,sigma=bw.diggle,edge=TRUE,kernel="gaussian")
```
display
```{R}
plot(acledmy_ppp_q3_bw)
```

```{r}
library(MASS)
for (q in 1) {
  
  # 提取坐标点
  coordinates <- st_coordinates(q3_data)
  lon <- coordinates[, 1]  # 经度
  lat <- coordinates[, 2]  # 纬度
  
  # 生成 KDE
  ppp_data <- ppp(lon, lat, window = boundary_owin)
  
  kde <- density(ppp_data)
  
  # 转换为 raster 并可视化
  kde_raster <- raster(kde)
  plot(kde_raster, main = paste("q3_data", q))
}
```

### 4.4 q4
```{R}
acledmy_ppp_q4_bw <- density(acledmy_ppp_q4,sigma=bw.diggle,edge=TRUE,kernel="gaussian")
```
display
```{R}
plot(acledmy_ppp_q4_bw)
```

```{R}
library(MASS)
for (q in 1) {
  
  # 提取坐标点
  coordinates <- st_coordinates(q4_data)
  lon <- coordinates[, 1]  # 经度
  lat <- coordinates[, 2]  # 纬度
  
  # 生成 KDE
  ppp_data <- ppp(lon, lat, window = boundary_owin)
  
  kde <- density(ppp_data)
  
  # 转换为 raster 并可视化
  kde_raster <- raster(kde)
  plot(kde_raster, main = paste("q4_data", q))
}
```